   # Задание 1

   1.1. Актуальное состояние товаров на 2020-06-01

   Через оконные функции  
   «Разметим» таблицу items в виде интервалов [valid_from, valid_to), в течение которых каждая цена действительна.

   ```sql
   WITH items_validity AS (
   	SELECT
       	item_id,
       	name,
       	price,
       	update_date AS valid_from,
       	LEAD(update_date, 1, DATE '9999-12-31')
           	OVER (PARTITION BY item_id ORDER BY update_date) AS valid_to
   	FROM items
   )
   SELECT
   	iv.item_id,
   	iv.name,
   	iv.price,
   	iv.valid_from AS update_date
   FROM items_validity iv
   WHERE iv.valid_from <= DATE '2020-06-01'
     AND iv.valid_to   >  DATE '2020-06-01';
   ```

   Через подзапрос с группировкой (когда оконных функций нет)

   ```sql
   SELECT i.item_id,
      	i.name,
      	i.price,
      	i.update_date
   FROM items i
   JOIN (
   	SELECT item_id,
          	MAX(update_date) AS last_update
   	FROM items
   	WHERE update_date <= DATE '2020-06-01'
   	GROUP BY item_id
   ) t ON i.item_id	= t.item_id
      AND i.update_date = t.last_update;
   ```

   В подзапросе получаем для каждого item_id самую позднюю дату обновления, не превышающую 2020-06-01  
   Затем соединяем это с основной таблицей items, чтобы подтянуть price, name и т. д.

   Далее для вопросов 2–5 нам нужно к каждому заказу определить актуальную цену — то есть взять последнюю запись items, у которой update_date ≤ order_date. Чтобы не дублировать один и тот же подзапрос в каждом пункте, сначала создадим единое CTE actual_prices.

   ```sql
   WITH actual_prices AS (
   	SELECT
       	o.order_id,
       	o.user_id,
       	o.item_id,
       	o.order_date,
       	(
           	SELECT i.price
           	FROM items i
           	WHERE i.item_id = o.item_id
             	AND i.update_date <= o.order_date
           	ORDER BY i.update_date DESC
           	LIMIT 1
       	) AS actual_price
   	FROM orders o
   )
   ```

   1.2 Товары, купленные по цене больше или равно 3

   ```sql
   SELECT
   	order_id,
   	user_id,
   	item_id,
   	order_date,
   	actual_price
   FROM actual_prices
   WHERE actual_price >= 3;
   ```

   1.3. Сумма покупок клиента 1

   ```sql
   SELECT
   	SUM(actual_price) AS total_for_user_1
   FROM actual_prices
   WHERE user_id = 1;
   ```

   1.4. Сумма всех покупок до 2020-05-01 включительно

   ```sql
   SELECT
   	SUM(actual_price) AS total_before_may
   FROM actual_prices
   WHERE order_date <= DATE '2020-05-01';
   ```

   1.5. Сумма всех заказов и средняя цена заказа поквартально

   ```sql
   SELECT
   	DATE_TRUNC('quarter', order_date) AS quarter_start,
   	SUM(actual_price)              	AS total_amount,
   	AVG(actual_price)              	AS average_price
   FROM actual_prices
   GROUP BY DATE_TRUNC('quarter', order_date)
   ORDER BY quarter_start;
   ```

   1.6. Как оптимизировать запросы для больших объемов данных.

   - **Индексы**  
     Можно создать индекс по (item_id, update_date) в таблице items, чтобы быстро находить нужную запись, удовлетворя условию WHERE item_id = ? AND update_date <= ? ORDER BY update_date DESC. Без такого индекса СУБД может вынужденно сканировать всю таблицу для каждого заказа. Если часто приходится фильтровать по датам заказов или по пользователям - полезно иметь индексы по orders(order_date) или (user_id, order_date).

   - **Материализация актуальных цен**  
     Если структура цен меняется не слишком часто, а запросы к этим данным идут постоянно, можно «предрассчитывать» периоды действия цены (через оконную функцию LEAD/ LAG) и хранить в отдельной таблице или представлении поля valid_from/valid_to. Тогда каждый заказ можно быстро сопоставлять с нужным «интервалом» цены, без сортировки и поиска в онлайне.

   - **Партиционирование**  
     Разделить таблицу orders (и items, если нужно)  на партиции по дате, если объём огромен и часто запрашиваются данные за свежие периоды или, наоборот, за архив.

   - **LATERAL / JOIN + правильный план**  
     Если какие-то итоги или актуальные цены нужны очень часто (например, в реальном сервисе), можно кэшировать результаты в Redis или Memcached либо обновлять специальные «агрегированные» таблицы или материализованные представления, а затем из них быстро выбирать данные.

   # Задание 2

   У нас есть поток заказов, примерно 100 000 заказов в день, которые записываются в таблицу `orders`.  
   Эти данные переливаются в DWH, но есть сложность:

   - В первые 6 месяцев заказы активно изменяются (например, обновляется статус, состав заказа, стоимость и т. д.).
   - Далее в течение 2-5 лет возможны редкие изменения.
   - Мы не можем использовать метку времени обновления (`updated_at` или аналоги).

   2.1. Как можно построить архитектуру DWH на основе Data Vault 2.0, чтобы:
   	- Обеспечить актуальность данных (иметь "актуальную" таблицу заказов).
   	- Эффективно хранить изменения, учитывая разные паттерны обновлений.
   	- Не терять историчность (возможность "путешествовать" во времени).

   **Общие принципы Data Vault**  
   	Hub — хранит «бизнес-ключи» (идентификаторы) с минимальным набором технических полей (hash key, load date, record source).  
   	Link — отражает связи (отношения «заказ–товар», «заказ–клиент», и т. д.) между hub’ами.  
   	Satellite — хранит атрибуты (описания, статусы), которые изменяются во времени, для каждой сущности (hub) или связи (link).  
   	Ключевой момент в Data Vault 2.0 — вся история изменений уходит в Sattelite-таблицы, причём для каждой версии записи хранится её Load Date (дата загрузки в DWH), концевик (когда запись перестала быть актуальной) и/или версия хэша-данных. Мы используем момент загрузки в DWH и сравнение хэшей, чтобы определить, изменились ли данные.

   **Хранение актуальной версии и историчности**

   	В «Raw Vault» мы храним все пришедшие изменения, каждое в своей строчке satellite.  
   	Для «актуальной» таблицы:
       	Либо строим PIT (Point-In-Time) Table — специальную таблицу, которая собирает для каждой записи (hub key) последнюю актуальную версию атрибутов из satellites на определённую дату.  
       	Либо используем Latest-satellite view (SELECT со склейками hub+sat, где для каждого hub берётся запись sat с максимальным load_date/версиями, которая не просрочена).  
       	Эти структуры мы уже можем считать частью Business Vault или Information Mart, в зависимости от подхода.

   Таким образом, Data Vault позволяет:

   	- Не терять ни одной версии (вся история в satellites).
   	- Иметь быстрое получение «текущего состояния» через PIT-таблицу или сверку последних записей.
   	- "Путешествовать во времени" — механизм PIT и эффективных дат в sat-записях даёт возможность собрать состояние системы на любую историческую дату.

   Чтобы учесть разные паттерны обновлений мы можем применить настройку разных satellites:

   - **Satellite_FastChanges** (например, status, total_amount, discount, — всё, что в первые полгода меняется много раз). Там будут происходить массовые дельты.
   - **Satellite_SlowChanges** (какие-то константные или почти статичные параметры заказа).

   Поскольку в первые 6 месяцев много изменений, а потом мало, в Satellite_FastChanges можно закрывать старые записи (End Dating), если изменения редкие. Если заказ изменился в течение первых 6 месяцев, мы просто добавляем новую запись с load_date, без end_date.  
   Если заказ больше не меняется (например, после 6 месяцев), мы закрываем запись, установив end_date = load_date следующей записи или NULL, если запись актуальна.  
   Таким образом:

   	- В период активных изменений (первые 6 месяцев) каждое изменение фиксируется.
   	- После 6 месяцев новые версии записываются только если что-то действительно поменялось.
   	- Можно быстро получтьь актуальные данные, т.к. не нужно просматривать 100+ строк на один заказ.

   Так как заказы после 6 месяцев почти не меняются, нам нужен быстрый доступ к последней версии. Для этого нужна PIT (Point-In-Time) таблица. PIT хранит ссылки на актуальные записи в каждом Satellite. Она обновляется раз в день/неделю и позволяет быстро получать актуальные данные.

   таким образом мы
   * Не теряем историю изменений (Data Vault даёт полный контроль версионности).
   * Оптимизируем хранение (разделяя часто и редко меняющиеся данные).
   * Обеспечиваем быстрые запросы на «текущий» статус заказа без сканирования всей истории.

   3. Как можно обновлять актуальное состояние заказов без использования `updated_at`?

   Нам не обязательно иметь явное поле updated_at в источнике. Мы используем:

   	load_date — дату/время, когда запись загрузилась или обновилась в хранилище.  
   	hash_diff — хеш от набора атрибутов. Если при загрузке новой версии данные в атрибутах изменились, то хеш будет отличаться от предыдущего.

   	Таким образом при поступлении данных из источника мы определяем (по order_id), существует ли уже такая запись в Hub. Если новая, то создаём Hub_Orders. Если есть, то переходим к Satellite.  
   	В Satellite (например, Satellite_FastChanges) рассчитываем hash_diff для набора атрибутов (статус, сумма, скидка и т. д.) и сравниваем с предыдущим hash_diff.  
   	Если хеш совпадает, значит атрибуты не менялись → не добавляем новую строку.  
   	Если хеш отличается, значит есть изменение → записываем новую версию с новой load_date.

   Обновление актуального состояния происходит благодаря вставкам новых версий в Satellites (каждая новая версия — новая строка). Полная история сохраняется в Satellite. Актуальная версия — это запись с самым поздним load_date и без end_date для данного order_hk.

   4. Как можно оптимизировать работу с данными такого рода?

   - **Разделение Satellite на «частые» и «редкие» изменения.** Satellite_FastChanges для полей, которые в первые месяцы меняются много (статус, сумма, скидка и т. д.), Satellite_SlowChanges для редко меняющихся полей (адрес, статические атрибуты и т. д.).

   - **После 6 месяцев можно закрывать версии в Satellite через поле end_date** и не создавать новые, пока не произойдёт реальное изменение. Так в таблицах не скапливаются ненужные копии записей.

   - **PIT и Bridge таблицы.** PIT (Point-In-Time) — сводная таблица, где для каждого hub key (например, order_hk) записана актуальная версия из Satellites. Ускоряет аналитические запросы, давая готовый срез. Bridge помогает денормализовать связи «многие ко многим» (например, «Заказ ↔ Товары»), ускоряя массовую аналитику.

   - **Партиционирование Satellite-таблиц по интервалам** (например, «активные 6 месяцев» и «архив») упрощает поддержание и ускоряет чтение. Старые партиции можно поместить в «холодное» хранилище, если изменений в них практически нет.

   - **Индексация по хеш-ключам** (хабам, линкам) и по load_date избавляет от сравнения всех полей — достаточно сверить старый и новый хеши.

   - **Если часто нужны отчёты по актуальному состоянию, можно создавать материализованные представления** на базе PIT. При больших нагрузках также можно применить внешнее кэширование (Redis или аналоги).
